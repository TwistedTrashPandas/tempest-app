// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeParticlesLightingCS
#pragma kernel SmoothParticlesLightingCS

#include "structs.cginc"
#include "common.cginc"
#include "UnityCG.cginc"
#include "AutoLight.cginc"
#include "Lighting.cginc"

static const float g_fCloudExtinctionCoeff = 100;

// Minimal cloud transparancy not flushed to zero
static const float g_fTransparencyThreshold = 0.01;

// Fraction of the particle cut off distance which serves as
// a transition region from particles to flat clouds
static const float g_fParticleToFlatMorphRatio = 0.2;

static const float g_fTimeScale = 1.f;
static const float2 g_f2CloudDensitySamplingScale = float2(1.f / 200000.f, 1.f / 20000.f);

Texture2DArray<float>  g_tex2DLightSpaceDepthMap_t0 : register(t0);
Texture2DArray<float>  g_tex2DLiSpCloudTransparency : register(t0);
Texture2DArray<float2> g_tex2DLiSpCloudMinMaxDepth  : register(t1);
Texture2D<float>       g_tex2DCloudDensity          : register(t1);
Texture2D<float3>      g_tex2DWhiteNoise            : register(t3);
Texture3D<float>       g_tex3DNoise                 : register(t4);
Texture2D<float>       g_tex2MaxDensityMip          : register(t3);
StructuredBuffer<uint> g_PackedCellLocations        : register(t0);
StructuredBuffer<SCloudCellAttribs> g_CloudCells    : register(t2);
StructuredBuffer<SParticleAttribs>  g_Particles     : register(t3);
Texture2D<float3>       g_tex2DAmbientSkylight               : register(t7);
StructuredBuffer<uint>              g_VisibleParticleFlags   : register(t6);
StructuredBuffer<SCloudParticleLighting> g_ParticlesLighting : register(t7);
Texture2DArray<float>   g_tex2DLightSpCloudTransparency      : register(t6);
Texture2DArray<float2>  g_tex2DLightSpCloudMinMaxDepth       : register(t7);
Texture2D<int>          g_tex2DFirstKnot                     : register(t8);
StructuredBuffer<SParticleListKnot> g_TiledParticlesList     : register(t9);
StructuredBuffer<uint>  g_ParticleOrder                      : register(t11);
Buffer<uint>            g_ValidCellsCounter                  : register(t0);
StructuredBuffer<uint>  g_ValidCellsUnorderedList            : register(t1);
StructuredBuffer<uint>  g_ValidParticlesUnorderedList        : register(t1);
StructuredBuffer<uint>  g_SortedParticlesOrder               : register(t0);
Texture3D<float2>       g_tex3DParticleDensityLUT    : register(t10);
Texture3D<float>        g_tex3DSingleScatteringInParticleLUT   : register(t11);
Texture3D<float>        g_tex3DMultipleScatteringInParticleLUT : register(t12);

StructuredBuffer<float4> g_SunLightAttenuation : register(t4);

RWStructuredBuffer<SCloudParticleLighting> g_ParticlesLightingRW : register(u0);
RWStructuredBuffer<float4>                 g_SunLightAttenuationRW : register(u1);

SamplerState MyLinearClampSampler : register(s0);
SamplerState MyLinearRepeatSampler : register(s1);

static SGlobalCloudAttribs g_GlobalCloudAttribs;

float3 GetParticleScales(in float fSize, in float fNumActiveLayers)
{
	float3 f3Scales = fSize;
	//if( fNumActiveLayers > 1 )
	//    f3Scales.y = max(f3Scales.y, g_GlobalCloudAttribs.fCloudThickness/fNumActiveLayers);
	f3Scales.y = min(f3Scales.y, g_GlobalCloudAttribs.fCloudThickness / 2.f);
	return f3Scales;
}

void IntersectRayWithParticle(const in SParticleAttribs ParticleAttrs,
	const in SCloudCellAttribs CellAttrs,
	const in float3 f3CameraPos,
	const in float3 f3ViewRay,
	out float2 f2RayIsecs,
	out float3 f3EntryPointUSSpace, // Entry point in Unit Sphere (US) space
	out float3 f3ViewRayUSSpace,    // View ray direction in Unit Sphere (US) space
	out float3 f3LightDirUSSpace,   // Light direction in Unit Sphere (US) space
	out float fDistanceToEntryPoint,
	out float fDistanceToExitPoint)
{
	// Construct local frame matrix
	float3 f3Normal = CellAttrs.f3Normal.xyz;
	float3 f3Tangent = CellAttrs.f3Tangent.xyz;
	float3 f3Bitangent = CellAttrs.f3Bitangent.xyz;
	float3x3 f3x3ObjToWorldSpaceRotation = float3x3(f3Tangent, f3Normal, f3Bitangent);
	// World to obj space is inverse of the obj to world space matrix, which is simply transpose
	// for orthogonal matrix:
	float3x3 f3x3WorldToObjSpaceRotation = transpose(f3x3ObjToWorldSpaceRotation);

	// Compute camera location and view direction in particle's object space:
	float3 f3CamPosObjSpace = f3CameraPos - ParticleAttrs.f3Pos;
	f3CamPosObjSpace = mul(f3CamPosObjSpace, f3x3WorldToObjSpaceRotation);
	float3 f3ViewRayObjSpace = mul(f3ViewRay, f3x3WorldToObjSpaceRotation);
	float3 f3LightDirObjSpce = mul(-_WorldSpaceLightPos0.xyz, f3x3WorldToObjSpaceRotation);

	// Compute scales to transform ellipsoid into the unit sphere:
	float3 f3Scale = 1.f / GetParticleScales(ParticleAttrs.fSize, CellAttrs.uiNumActiveLayers);

	float3 f3ScaledCamPosObjSpace;
	f3ScaledCamPosObjSpace = f3CamPosObjSpace * f3Scale;
	f3ViewRayUSSpace = normalize(f3ViewRayObjSpace*f3Scale);
	f3LightDirUSSpace = normalize(f3LightDirObjSpce*f3Scale);
	// Scale camera pos and view dir in obj space and compute intersection with the unit sphere:
	GetRaySphereIntersection(f3ScaledCamPosObjSpace, f3ViewRayUSSpace, 0, 1.f, f2RayIsecs);

	f3EntryPointUSSpace = f3ScaledCamPosObjSpace + f3ViewRayUSSpace * f2RayIsecs.x;

	fDistanceToEntryPoint = length(f3ViewRayUSSpace / f3Scale) * f2RayIsecs.x;
	fDistanceToExitPoint = length(f3ViewRayUSSpace / f3Scale) * f2RayIsecs.y;
}

float2 ComputeLiSpTransparency(const in SParticleAttribs ParticleAttrs)
{
	float4 f4ParticleCenterPosPS = mul(float4(ParticleAttrs.f3Pos, 1), g_GlobalCloudAttribs.mParticleTiling);
	float2 f2ParticleProjSpaceXY = f4ParticleCenterPosPS.xy / f4ParticleCenterPosPS.w;
	if (any(abs(f2ParticleProjSpaceXY) > 1))
		return 1;

	float2 f2ParticleUV = saturate(ProjToUV(f2ParticleProjSpaceXY));

	float3 f3RayStart = ParticleAttrs.f3Pos.xyz;
	float3 f3RayDir = g_LightAttribs.f4DirOnLight.xyz;

	uint2 uiTileXY = floor(f2ParticleUV * g_GlobalCloudAttribs.uiLiSpFirstListIndTexDim);
	int iCurrKnotInd = g_tex2DFirstKnot.Load(uint3(uiTileXY, 0));
	float2 f2Transparency = 1;

	[loop]
	while (iCurrKnotInd >= 0)
	{
		SParticleListKnot CurrKnot = g_TiledParticlesList[iCurrKnotInd];
		SParticleAttribs CurrParticleAttrs = g_Particles[CurrKnot.uiParticleID];
		SCloudCellAttribs CurrCellAttrs = g_CloudCells[CurrKnot.uiParticleID / max(g_GlobalCloudAttribs.uiMaxLayers, 1)];

		float2 f2RayIsecs;
		float fDistanceToEntryPoint, fDistanceToExitPoint;
		float3 f3EntryPointUSSpace, f3ViewRayUSSpace, f3LightDirUSSpace;
		IntersectRayWithParticle(CurrParticleAttrs, CurrCellAttrs, f3RayStart, f3RayDir,
			f2RayIsecs, f3EntryPointUSSpace, f3ViewRayUSSpace,
			f3LightDirUSSpace,
			fDistanceToEntryPoint, fDistanceToExitPoint);

		float2 f2CurrTransparency = 1.f;
		if ( //CurrKnot.uiParticleID != uiParticleOrder && 
			fDistanceToExitPoint > 0
			/*f2RayIsecs.y > f2RayIsecs.x && */)
		{
			//float fDensityScale = 1;
			//float fDensity = ParticleAttrs.fDensity * fDensityScale;
			fDistanceToEntryPoint = max(fDistanceToEntryPoint, CurrParticleAttrs.fSize);
			float fCloudMass = max(fDistanceToExitPoint - fDistanceToEntryPoint, 0);//g_GlobalCloudAttribs.fCloudVolumeDensity * fDensity;
			fCloudMass *= CurrCellAttrs.fMorphFadeout * ParticleAttrs.fDensity;
			f2CurrTransparency = exp(-fCloudMass * g_GlobalCloudAttribs.fAttenuationCoeff * float2(0.05, 0.025));
		}

		f2Transparency *= f2CurrTransparency;
		if ((f2Transparency.x < g_fTransparencyThreshold) && (f2Transparency.y < g_fTransparencyThreshold))
			break;

		iCurrKnotInd = CurrKnot.iNextKnotInd;
	}

	//fTransparency = saturate((fTransparency - g_fTransparencyThreshold) / (1-g_fTransparencyThreshold));

	return f2Transparency;
}
void GetSunLightExtinctionAndSkyLight(in float3 f3PosWS,
	out float3 f3Extinction,
	out float3 f3AmbientSkyLight,
	Texture2D<float2> tex2DOccludedNetDensityToAtmTop,
	Texture2D<float3> tex2DAmbientSkylight)
{
	float3 f3EarthCentre = float3(0, -g_MediaParams.fEarthRadius, 0);
	float3 f3DirFromEarthCentre = f3PosWS - f3EarthCentre;
	float fDistToCentre = length(f3DirFromEarthCentre);
	f3DirFromEarthCentre /= fDistToCentre;
	float fHeightAboveSurface = fDistToCentre - g_MediaParams.fEarthRadius;
	float fCosZenithAngle = dot(f3DirFromEarthCentre, g_LightAttribs.f4DirOnLight.xyz);

	float fRelativeHeightAboveSurface = fHeightAboveSurface / g_MediaParams.fAtmTopHeight;
	float2 f2ParticleDensityToAtmTop = g_tex2DOccludedNetDensityToAtmTop.SampleLevel(MyLinearClampSampler, float2(fRelativeHeightAboveSurface, fCosZenithAngle*0.5 + 0.5), 0).xy;

	float3 f3RlghOpticalDepth = g_MediaParams.f4RayleighExtinctionCoeff.rgb * f2ParticleDensityToAtmTop.x;
	float3 f3MieOpticalDepth = g_MediaParams.f4MieExtinctionCoeff.rgb      * f2ParticleDensityToAtmTop.y;

	// And total extinction for the current integration point:
	f3Extinction = exp(-(f3RlghOpticalDepth + f3MieOpticalDepth));

	f3AmbientSkyLight = tex2DAmbientSkylight.SampleLevel(MyLinearClampSampler, float2(fCosZenithAngle*0.5 + 0.5, 0.5), 0);
}

// This shader compute lighting for all valid particles
[numthreads(256, 1, 1)]
void ComputeParticlesLightingCS(uint3 Gid  : SV_GroupID,
	uint3 GTid : SV_GroupThreadID)
{
	uint uiParticleSerialNum = Gid.x * 256 + GTid.x;
	uint uiNumValidParticles = g_ValidCellsCounter.Load(0);
	if (uiParticleSerialNum >= uiNumValidParticles)
		return;

	uint uiParticleId = g_ValidParticlesUnorderedList[uiParticleSerialNum];

	bool bIsVisible = g_VisibleParticleFlags[uiParticleId / 32] & (1 << (uiParticleId & 31));
	if (!bIsVisible)
		return;

	uint uiCellId = uiParticleId / max(g_GlobalCloudAttribs.uiMaxLayers, 1);
	SParticleAttribs ParticleAttrs = g_Particles[uiParticleId];

	float3 f3AtmosphereExtinction, f3AmbientSkyLight;
	GetSunLightExtinctionAndSkyLight(ParticleAttrs.f3Pos, f3AtmosphereExtinction, f3AmbientSkyLight, g_tex2DOccludedNetDensityToAtmTop, g_tex2DAmbientSkylight);
	g_ParticlesLightingRW[uiParticleId].f4SunLight = float4(f3AtmosphereExtinction * g_LightAttribs.f4ExtraterrestrialSunColor.rgb, 0);
	g_ParticlesLightingRW[uiParticleId].f4AmbientLight = float4(f3AmbientSkyLight, 1);

	float2 f2CloudLiSpTransparency = ComputeLiSpTransparency(ParticleAttrs);

	SCloudCellAttribs CellAttrs = g_CloudCells[uiCellId];
	uint uiCellX, uiCellY, uiRing, uiLayerUnused;
	UnPackParticleIJRing(CellAttrs.uiPackedLocation, uiCellX, uiCellY, uiRing, uiLayerUnused);
	uint uiLayer = uiParticleId % max(g_GlobalCloudAttribs.uiMaxLayers, 1);
	uint uiDirectID =
		(uiRing * g_GlobalCloudAttribs.uiRingDimension * g_GlobalCloudAttribs.uiRingDimension +
			uiCellX + uiCellY * g_GlobalCloudAttribs.uiRingDimension) * g_GlobalCloudAttribs.uiMaxLayers +
		uiLayer;
	g_SunLightAttenuationRW[uiDirectID] = float4(f2CloudLiSpTransparency, 0, ParticleAttrs.fDensity);
}

// This shader compute lighting for all valid particles
[numthreads(256, 1, 1)]
void SmoothParticlesLightingCS(uint3 Gid  : SV_GroupID,
	uint3 GTid : SV_GroupThreadID)
{
	uint uiParticleSerialNum = Gid.x * 256 + GTid.x;
	uint uiNumValidParticles = g_ValidCellsCounter.Load(0);
	if (uiParticleSerialNum >= uiNumValidParticles)
		return;

	uint uiParticleId = g_ValidParticlesUnorderedList[uiParticleSerialNum];

	bool bIsVisible = g_VisibleParticleFlags[uiParticleId / 32] & (1 << (uiParticleId & 31));
	if (!bIsVisible)
		return;

	uint uiCellId = uiParticleId / max(g_GlobalCloudAttribs.uiMaxLayers, 1);
	SCloudCellAttribs CellAttrs = g_CloudCells[uiCellId];
	uint uiCellX, uiCellY, uiRing, uiLayerUnused;
	UnPackParticleIJRing(CellAttrs.uiPackedLocation, uiCellX, uiCellY, uiRing, uiLayerUnused);
	uint uiLayer = uiParticleId % max(g_GlobalCloudAttribs.uiMaxLayers, 1);
	uint uiDirectID =
		(uiRing * g_GlobalCloudAttribs.uiRingDimension * g_GlobalCloudAttribs.uiRingDimension +
			uiCellX + uiCellY * g_GlobalCloudAttribs.uiRingDimension) * g_GlobalCloudAttribs.uiMaxLayers +
		uiLayer;

	float4 f4SmoothedAttenuation = float4(0,0,0,0);
	float fTotalWegith = 0;
#define CHECK_NEIGHB_PARTICLE(i, j, l)\
    {                                                                                   \
        uint uiSrcParticleID = uiDirectID + ((i) + (j) * g_GlobalCloudAttribs.uiRingDimension) * g_GlobalCloudAttribs.uiMaxLayers + l; \
        float4 f4SrcSunLightAtt = g_SunLightAttenuation[uiSrcParticleID];                   \
        if( f4SrcSunLightAtt.a > 0 )                                                       \
        {                                                                               \
            f4SmoothedAttenuation += float4(f4SrcSunLightAtt.rg*f4SrcSunLightAtt.a, 0, f4SrcSunLightAtt.a);   \
        }                                                                               \
    }

	bool bHasLeftNeighb = uiCellX >= 1;
	bool bHasRightNeighb = uiCellX < g_GlobalCloudAttribs.uiRingDimension - 1;
	bool bHasBottomNeighb = uiCellY >= 1;
	bool bHasTopNeighb = uiCellY < g_GlobalCloudAttribs.uiRingDimension - 1;

	CHECK_NEIGHB_PARTICLE(0, 0, 0)
		if (bHasLeftNeighb)  CHECK_NEIGHB_PARTICLE(-1, 0, 0)
			if (bHasRightNeighb) CHECK_NEIGHB_PARTICLE(+1, 0, 0)
				if (bHasBottomNeighb)CHECK_NEIGHB_PARTICLE(0, -1, 0)
					if (bHasTopNeighb)   CHECK_NEIGHB_PARTICLE(0, +1, 0)
						if (uiLayer < CellAttrs.uiNumActiveLayers - 1)
							CHECK_NEIGHB_PARTICLE(0, 0, +1)
							if (uiLayer > 1)
								CHECK_NEIGHB_PARTICLE(0, 0, -1)

								f4SmoothedAttenuation.rgb /= max(f4SmoothedAttenuation.a, 1e-5);
	g_ParticlesLightingRW[uiParticleId].f4LightAttenuation = float4(f4SmoothedAttenuation.xy, 1, 1);
}