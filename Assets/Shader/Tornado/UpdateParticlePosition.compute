// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdateParticles

RWStructuredBuffer<float3> particlePosRW: register(u0);
RWStructuredBuffer<float3> particleVelRW: register(u1);
RWStructuredBuffer<int> particleVisibilityRW: register(u2);
StructuredBuffer<float3> vectorFieldIn: register(t0);

float3 g_i3Dimensions;
float3 g_f3CellSizes;
float3 g_f3Center;
float3 g_f3MaxVel;
float3 g_f3RandPos;
float3 g_f3ShipPosition;
float g_fTimestep;
float g_fDampVel;
float g_fMaxDist;
uint g_iNumCloudSkyParticles;
int g_bEndAnimation;

[numthreads(256, 1, 1)]
void UpdateParticles(uint3 id : SV_DispatchThreadID)
{
	if (particleVisibilityRW[id.x] == 0)
		return;
	if (id.x >= g_iNumCloudSkyParticles) {
		// get idx of grid for every particle
		float3 position = particlePosRW[id.x];
		int3 idx = (int3)(position / (g_f3CellSizes));
		idx.y = min(g_i3Dimensions.y - 1, max(idx.y, 0));
		float x_proj = position.x - g_f3Center.x;
		float z_proj = position.z - g_f3Center.z;
		if ((idx.x < 0 || idx.x >= g_i3Dimensions.x) || (idx.z < 0 || idx.z >= g_i3Dimensions.z))
		{
			if (abs(x_proj) > abs(z_proj))
			{
				z_proj /= x_proj;
				x_proj = sign(x_proj);
				z_proj *= x_proj;
			}
			else
			{
				x_proj /= z_proj;
				z_proj = sign(z_proj);
				x_proj *= z_proj;
			}
			idx.x = (int)((x_proj * 0.5f + 0.5f) * (g_i3Dimensions.x - 1));
			idx.z = (int)((z_proj * 0.5f + 0.5f) * (g_i3Dimensions.z - 1));
		}
		// update velocity and positions accordingly (TODO improve performance by precomputing set calculations)
		float dims = g_i3Dimensions[1] * g_i3Dimensions[2];
		float3 velocity = particleVelRW[id.x];

		if (g_bEndAnimation) {
			//float3 direction = g_f3ShipPosition - position;
			float dist = distance(position, g_f3ShipPosition);
			if (dist < 10.0f)
				particleVisibilityRW[id.x] = 0;
		}

		velocity *= g_fDampVel;
		velocity += vectorFieldIn[min(idx.x * dims + idx.y * g_i3Dimensions[2] + idx.z, dims*g_i3Dimensions[0])] * g_fTimestep;
		velocity.y = max(-g_f3MaxVel.y, min(g_f3MaxVel.y, velocity.y));

		float2 tempVel = float2(velocity.x, velocity.z);
		if (length(tempVel) > g_f3MaxVel.x) {
			tempVel = normalize(tempVel) * g_f3MaxVel.x;
		}
		velocity.xz = tempVel.xy;

		position += velocity * g_fTimestep;

		if (distance(position.xz, g_f3Center.xz) > g_fMaxDist || position.y > g_i3Dimensions[1] * g_f3CellSizes.y) {
			//particlePosRW[id.x].xz = (particlePosRW[id.x].xz - g_f3Center.xz) * ((id.x + 1) % 2) / 1.5f + g_f3Center.xz;
			float2 dir = position.xz - g_f3Center.xz;
			position.xz = (dir) * ((id.x) % 7) / 5.5f + g_f3Center.xz; // (dir) * min((id.x) % 2, 1) / 2.2f +
			position.y -= g_f3Center.y * 2;
			velocity *= g_f3RandPos;// float3(0.0f, 0.0f, 0.0f);
		}
		particlePosRW[id.x] = position;
		particleVelRW[id.x] = velocity;
	}/*
	else {
		particlePosRW[id.x].y = g_i3Dimensions[1] * g_i3Dimensions.w * 1.1f;
		particleVelRW[id.x].y = 0.0f;
	}*/
}
