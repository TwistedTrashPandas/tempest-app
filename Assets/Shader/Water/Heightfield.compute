#pragma kernel updateHeightfield
#pragma kernel interpolateVertices

struct HeightField {
	float height;
	float velocity;
};

float g_fSpeed;			//	speed of the waves
float g_fDamping;
float g_fMaxVelocity;
float g_fDeltaTime;		//	timeStep
float g_fTotalTime;
float g_fMaxHeight;
float g_fGridSpacing;
float g_fQuadSize;		//	size of the quads of the mesh
float g_fAvgHeight;		//	avgerage height, computed on CPU
uint g_iDepth;			//	depth of the heightfield
uint g_iWidth;			//	width "-"
float g_fGravity;
float g_fManning;
float g_fDx;
float g_fDy;

RWStructuredBuffer<HeightField> heightFieldOut : register(u0);
StructuredBuffer<HeightField> heightFieldIn : register(t0);
StructuredBuffer<uint> reflectWaves : register(t1);

static const float SGNLUT[] =
{
	-1, -1, 1, 1, 1, -1, -1,
	-1, 1, -1, -1, -1, 1, -1,
	1, -1, 1, 1, 1, -1, 1,
	1, -1, 1, 0, 1, -1, 1,
	1, -1, 1, 1, 1, -1, 1,
	-1, 1, -1, -1, -1, 1, -1,
	-1, -1, 1, 1, 1, -1, -1
};

[numthreads(16, 16, 1)]
void updateHeightfield(uint3 id : SV_DispatchThreadID)
{
	//	https://www.cs.ubc.ca/~rbridson/fluidsimulation/GameFluids2007.pdf
	//	http://matthias-mueller-fischer.ch/talks/GDC2008.pdf

	//	get corresponding indices of current thread
	int i = id.x;
	int j = id.y;

	if (i >= g_iWidth || j >= g_iDepth)
		return;

	//	let c be g_fSpeed, 
	//	v[i, j]_t the velocity of the heightfield at position i, j at timeStep t, 
	//	h[i,j]_t equivalent

	float totalHeight = 0.0f;

	//	calculate total height of surrounding values, consider obstacles
	if (reflectWaves[max(i - 1, 0) * g_iDepth + j] == 0)
		totalHeight += heightFieldIn[max(i - 1, 0) * g_iDepth + j].height;
	else
		totalHeight += heightFieldIn[i * g_iDepth + j].height;

	if (reflectWaves[min(g_iWidth - 1, i + 1) * g_iDepth + j] == 0)
		totalHeight += heightFieldIn[min(g_iWidth - 1, i + 1) * g_iDepth + j].height;
	else
		totalHeight += heightFieldIn[i * g_iDepth + j].height;

	if (reflectWaves[i * g_iDepth + max(j - 1, 0)] == 0)
		totalHeight += heightFieldIn[i * g_iDepth + max(j - 1, 0)].height;
	else
		totalHeight += heightFieldIn[i * g_iDepth + j].height;

	if (reflectWaves[i * g_iDepth + min(j + 1, g_iDepth - 1)] == 0)
		totalHeight += heightFieldIn[i * g_iDepth + min(g_iDepth - 1, min(j + 1, g_iDepth - 1))].height;
	else
		totalHeight += heightFieldIn[i * g_iDepth + j].height;

	float totalHeightDiag = 0.0f;

	if (reflectWaves[max(i - 1, 0) * g_iDepth + max(j - 1, 0)] == 0)
		totalHeightDiag += heightFieldIn[max(i - 1, 0) * g_iDepth + max(j - 1, 0)].height;
	else
		totalHeightDiag += heightFieldIn[i * g_iDepth + j].height;

	if (reflectWaves[min(g_iWidth - 1, i + 1) * g_iDepth + min(j + 1, g_iDepth - 1)] == 0)
		totalHeightDiag += heightFieldIn[min(g_iWidth - 1, i + 1) * g_iDepth + min(j + 1, g_iDepth - 1)].height;
	else
		totalHeightDiag += heightFieldIn[i * g_iDepth + j].height;

	if (reflectWaves[min(g_iWidth - 1, i + 1) * g_iDepth + max(j - 1, 0)] == 0)
		totalHeightDiag += heightFieldIn[min(g_iWidth - 1, i + 1) * g_iDepth + max(j - 1, 0)].height;
	else
		totalHeightDiag += heightFieldIn[i * g_iDepth + j].height;

	if (reflectWaves[max(i - 1, 0) * g_iDepth + min(j + 1, g_iDepth - 1)] == 0)
		totalHeightDiag += heightFieldIn[max(i - 1, 0) * g_iDepth + min(j + 1, g_iDepth - 1)].height;
	else
		totalHeightDiag += heightFieldIn[i * g_iDepth + j].height;

	//	different behaviour at obstacle or wall
	if (reflectWaves[i * g_iDepth + j] != 0) {
		heightFieldOut[i * g_iDepth + j].height = (totalHeight + totalHeightDiag) / 8.0f;
		//heightFieldOut[i * g_iDepth + j].height -= g_fAvgHeight;
	}
	else {
		//	wave equation in 2D, semi-implicit euler
		//	max and min used for clamping the boundary and reflecting the waves
		//	v[i, j]_(t+1) = v_t + dt * c * c * ((h[i - 1, j] + h[i + 1, j] + h[i, j + 1] + h[i, j - 1])- 4 * h[i, j]_t)	/ (g_fGridSpacing * g_fGridSpacing)
		heightFieldOut[i * g_iDepth + j].velocity = heightFieldIn[i * g_iDepth + j].velocity * g_fDamping + g_fDeltaTime * g_fSpeed * g_fSpeed *
			(totalHeight - 4 * (heightFieldIn[i * g_iDepth + j].height)) / (g_fGridSpacing * g_fGridSpacing); // + (totalHeightDiag - 4 * (heightFieldIn[i * g_iDepth + j].height)) / 1.0f

		int center_x = (int)g_iDepth / 2;
		int center_y = (int)g_iWidth / 2;
		int l_border = center_x;
		int r_border = center_x;
		r_border += 2;
		l_border -= 2;
		int u_border = center_y;
		int d_border = center_y;
		u_border += 2;
		d_border -= 2;

		//	clamping and damping of velocity
		heightFieldOut[i * g_iDepth + j].velocity = clamp(heightFieldOut[i * g_iDepth + j].velocity, -g_fMaxVelocity, g_fMaxVelocity);


		//	integrate height at timestep t+1:  h[i,j]_t+1 = h[i,j]_t + v[i,j]_t * dt 
		heightFieldOut[i * g_iDepth + j].height = heightFieldIn[i*g_iDepth + j].height + heightFieldOut[i * g_iDepth + j].velocity * g_fDeltaTime;

		//if (i <= r_border && i >= l_border && j >= d_border && j <= u_border) {
			float2 pos = float2(i - center_x, j - center_y);
			float2 cos_sin = float2(cos(g_fTotalTime), sin(g_fTotalTime));
			float dist = distance(pos, cos_sin) + 1.0f;
			if (dist < 5.0f) {
				//heightFieldOut[i * g_iDepth + j].velocity += heightFieldOut[i * g_iDepth + j].velocity * 0.01f * SGNLUT[sgn_x + sgn_y * 7] * distance;
				heightFieldOut[i * g_iDepth + j].height = 64.0f / (dist * dist);
			}
		//}
		//	keep average Height of all points at ca. 0
		// heightFieldOut[i * g_iDepth + j].height -= g_fAvgHeight;

		//	clamp height
		heightFieldOut[i * g_iDepth + j].height = clamp(heightFieldOut[i * g_iDepth + j].height, -g_fMaxHeight, g_fMaxHeight);
	}
}

RWStructuredBuffer<float3> verticesPosition : register(u1);
RWStructuredBuffer<float3> verticesNormal : register(u2);
StructuredBuffer<float2> randomDisplacement : register(t1);

[numthreads(256, 1, 1)]
void interpolateVertices(uint3 id : SV_DispatchThreadID) {
	uint i = id.x;

	if (i >= g_iWidth * g_iDepth)
		return;
	float3 pos = verticesPosition[i];
	uint k, m = 0;

	k = round(pos.x / g_fQuadSize);
	m = round(pos.z / g_fQuadSize);

	// get surrounding vertices to approximate normal by taking the gradient
	int idx1 = k * g_iDepth + m;
	int idx3 = k * g_iDepth + min(m + 1, g_iDepth - 1);
	int idx4 = min((k + 1), g_iWidth - 1) * g_iDepth + m;
	int idx5 = min((k - 1), 0) * g_iDepth + m;
	int idx6 = k * g_iDepth + max(m - 1, 0);

	float x1 = heightFieldIn[idx1].height;
	float x3 = heightFieldIn[idx3].height;
	float x4 = heightFieldIn[idx4].height;
	float x5 = heightFieldIn[idx5].height;
	float x6 = heightFieldIn[idx6].height;

	float gradX = (x4 - x5); // float3(1.0f, 0.0f, 0.0f);
	float gradZ = (x3 - x6); // float3(0.0f, 0.0f, 1.0f); 
	//gradX = -normalize(cross(gradX, gradZ));
	//if (gradX.y < 0)
	//	gradX *= -1.0f;
	verticesNormal[i] = -normalize(float3(2.0f * gradX, -4.0f, 2.0f * gradZ));// gradX;

	pos.x += randomDisplacement[k * g_iDepth + m].x;
	pos.z += randomDisplacement[k * g_iDepth + m].y;
	if (randomDisplacement[k * g_iDepth + m].x < 0)
		k -= 1;
	if (randomDisplacement[k * g_iDepth + m].y < 0)
		m -= 1;

	//	get surrounding height values at the vertex position (can be randomly displaced)
	x1 = heightFieldIn[k * g_iDepth + m].height;
	float x2 = heightFieldIn[min((k + 1), g_iWidth - 1) * g_iDepth + min(m + 1, g_iDepth - 1)].height;
	x3 = heightFieldIn[k * g_iDepth + min(m + 1, g_iDepth - 1)].height;
	x4 = heightFieldIn[min((k + 1), g_iWidth - 1) * g_iDepth + m].height;

	//	get x and y value between 0 and 1 for interpolation
	float x = (pos.x / g_fQuadSize - k);
	float y = (pos.z / g_fQuadSize - m);

	//	bilinear interpolation to get height at vertex i
	//	note if x == 0 and y == 0 vertex position is at heightfield position.
	float resultingHeight = (x1 * (1 - x) + x4 * (x)) * (1 - y) + (x3 * (1 - x) + x2 * (x)) * (y);
	pos.y = resultingHeight;

	verticesPosition[i] = pos;
}
